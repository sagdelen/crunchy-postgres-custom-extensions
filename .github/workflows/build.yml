name: Build and Push Docker Image

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      base_image_tag:
        description: "Custom base image tag (leave empty for default PG 17 & 18 builds)"
        required: false
        default: ""

jobs:
  # Default builds: PG 17 and PG 18 (runs on push or when no custom tag provided)
  build-default:
    if: github.event.inputs.base_image_tag == '' || github.event.inputs.base_image_tag == null
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - base_image_tag: ubi9-17.7-2550
            pg_version: "17"
          - base_image_tag: ubi9-18.1-2550
            pg_version: "18"
    outputs:
      pg17_image: ${{ steps.set-outputs.outputs.pg17_image }}
      pg18_image: ${{ steps.set-outputs.outputs.pg18_image }}
      pg17_tag: ${{ steps.set-outputs.outputs.pg17_tag }}
      pg18_tag: ${{ steps.set-outputs.outputs.pg18_tag }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate timestamp
        id: timestamp
        run: echo "ts=$(date -u +%Y%m%dT%H%M%SZ)" >> $GITHUB_OUTPUT

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            BASE_IMAGE_TAG=${{ matrix.base_image_tag }}
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/crunchy-postgres-custom:${{ matrix.base_image_tag }}-${{ steps.timestamp.outputs.ts }}
            ${{ secrets.DOCKERHUB_USERNAME }}/crunchy-postgres-custom:${{ matrix.base_image_tag }}
            ${{ secrets.DOCKERHUB_USERNAME }}/crunchy-postgres-custom:pg${{ matrix.pg_version }}-latest
          cache-from: type=gha,scope=${{ matrix.base_image_tag }}
          cache-to: type=gha,mode=max,scope=${{ matrix.base_image_tag }}

      - name: Set outputs for test job
        id: set-outputs
        run: |
          if [ "${{ matrix.pg_version }}" = "17" ]; then
            echo "pg17_image=${{ secrets.DOCKERHUB_USERNAME }}/crunchy-postgres-custom" >> $GITHUB_OUTPUT
            echo "pg17_tag=pg17-latest" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.pg_version }}" = "18" ]; then
            echo "pg18_image=${{ secrets.DOCKERHUB_USERNAME }}/crunchy-postgres-custom" >> $GITHUB_OUTPUT
            echo "pg18_tag=pg18-latest" >> $GITHUB_OUTPUT
          fi

  # Test both PG 17 and PG 18 images
  test-default:
    needs: build-default
    if: github.event.inputs.base_image_tag == '' || github.event.inputs.base_image_tag == null
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - pg_version: "17"
            image_tag: "pg17-latest"
          - pg_version: "18"
            image_tag: "pg18-latest"
    outputs:
      pg17_result: ${{ steps.test-result.outputs.pg17_result }}
      pg18_result: ${{ steps.test-result.outputs.pg18_result }}
      pg17_partitions_before: ${{ steps.test-result.outputs.pg17_partitions_before }}
      pg17_partitions_after: ${{ steps.test-result.outputs.pg17_partitions_after }}
      pg18_partitions_before: ${{ steps.test-result.outputs.pg18_partitions_before }}
      pg18_partitions_after: ${{ steps.test-result.outputs.pg18_partitions_after }}
      pg17_rows_before: ${{ steps.test-result.outputs.pg17_rows_before }}
      pg17_rows_after: ${{ steps.test-result.outputs.pg17_rows_after }}
      pg18_rows_before: ${{ steps.test-result.outputs.pg18_rows_before }}
      pg18_rows_after: ${{ steps.test-result.outputs.pg18_rows_after }}
      pg17_shared_libs: ${{ steps.test-result.outputs.pg17_shared_libs }}
      pg18_shared_libs: ${{ steps.test-result.outputs.pg18_shared_libs }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create Kind cluster
        uses: helm/kind-action@v1
        with:
          cluster_name: pgo-test

      - name: Install PGO
        run: |
          git clone --depth 1 https://github.com/CrunchyData/postgres-operator.git /tmp/pgo
          kubectl apply -k /tmp/pgo/config/namespace
          kubectl apply --server-side -k /tmp/pgo/config/default
          kubectl wait --for=condition=Available deployment/pgo -n postgres-operator --timeout=180s

      - name: Pull and load image
        run: |
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/crunchy-postgres-custom:${{ matrix.image_tag }}
          kind load docker-image ${{ secrets.DOCKERHUB_USERNAME }}/crunchy-postgres-custom:${{ matrix.image_tag }} --name pgo-test

      - name: Deploy PostgresCluster
        env:
          IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/crunchy-postgres-custom
          IMAGE_TAG: ${{ matrix.image_tag }}
          POSTGRES_VERSION: ${{ matrix.pg_version }}
        run: |
          envsubst < test/postgrescluster.yaml | kubectl apply -f -
          echo "Waiting for PostgresCluster to be ready..."
          for i in {1..60}; do
            READY=$(kubectl get postgrescluster partman-test -o jsonpath='{.status.instances[0].readyReplicas}' 2>/dev/null || echo "0")
            if [ "$READY" = "1" ]; then
              echo "PostgresCluster ready"
              break
            fi
            echo "Waiting... ($i/60)"
            sleep 5
          done

      - name: Setup pg_partman
        run: |
          POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')
          kubectl cp test/setup_partman.sql ${POD}:/tmp/setup_partman.sql -c database
          for db in db1 db2; do
            kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -f /tmp/setup_partman.sql -q
          done

      - name: Validate and capture results
        id: test-result
        run: |
          POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')

          # Check shared_preload_libraries
          SHARED_LIBS=$(kubectl exec ${POD} -c database -- psql -U postgres -t -c "SHOW shared_preload_libraries;" | tr -d ' ')
          echo "shared_preload_libraries: $SHARED_LIBS"

          RESULT="PASSED"

          # Test both databases
          for db in db1 db2; do
            echo "=== Testing ${db} ==="
            
            PARTITIONS_BEFORE=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM pg_tables WHERE tablename LIKE 'events_p%';" | tr -d ' ')
            ROWS_BEFORE=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM events;" | tr -d ' ')
            echo "Before: $PARTITIONS_BEFORE partitions, $ROWS_BEFORE rows"

            kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -c "CALL partman.run_maintenance_proc();" >/dev/null

            PARTITIONS_AFTER=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM pg_tables WHERE tablename LIKE 'events_p%';" | tr -d ' ')
            ROWS_AFTER=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM events;" | tr -d ' ')
            echo "After: $PARTITIONS_AFTER partitions, $ROWS_AFTER rows"

            DROPPED=$((PARTITIONS_BEFORE - PARTITIONS_AFTER))
            echo "Result: ${DROPPED} partitions dropped"

            if [ "$PARTITIONS_AFTER" -ge "$PARTITIONS_BEFORE" ]; then
              echo "FAILED: Retention not working in ${db}"
              RESULT="FAILED"
            fi

            # Save results for first db (db1) for summary
            if [ "$db" = "db1" ]; then
              echo "${db}_partitions_before=$PARTITIONS_BEFORE" >> $GITHUB_ENV
              echo "${db}_partitions_after=$PARTITIONS_AFTER" >> $GITHUB_ENV
              echo "${db}_rows_before=$ROWS_BEFORE" >> $GITHUB_ENV
              echo "${db}_rows_after=$ROWS_AFTER" >> $GITHUB_ENV
            fi
          done

          if ! echo "$SHARED_LIBS" | grep -q "pg_partman_bgw"; then
            echo "FAILED: pg_partman_bgw not in shared_preload_libraries"
            RESULT="FAILED"
          fi

          echo "Test result: $RESULT"

          # Set outputs based on PG version
          if [ "${{ matrix.pg_version }}" = "17" ]; then
            echo "pg17_result=$RESULT" >> $GITHUB_OUTPUT
            echo "pg17_partitions_before=$db1_partitions_before" >> $GITHUB_OUTPUT
            echo "pg17_partitions_after=$db1_partitions_after" >> $GITHUB_OUTPUT
            echo "pg17_rows_before=$db1_rows_before" >> $GITHUB_OUTPUT
            echo "pg17_rows_after=$db1_rows_after" >> $GITHUB_OUTPUT
            echo "pg17_shared_libs=$SHARED_LIBS" >> $GITHUB_OUTPUT
          else
            echo "pg18_result=$RESULT" >> $GITHUB_OUTPUT
            echo "pg18_partitions_before=$db1_partitions_before" >> $GITHUB_OUTPUT
            echo "pg18_partitions_after=$db1_partitions_after" >> $GITHUB_OUTPUT
            echo "pg18_rows_before=$db1_rows_before" >> $GITHUB_OUTPUT
            echo "pg18_rows_after=$db1_rows_after" >> $GITHUB_OUTPUT
            echo "pg18_shared_libs=$SHARED_LIBS" >> $GITHUB_OUTPUT
          fi

          if [ "$RESULT" = "FAILED" ]; then
            exit 1
          fi

  # Generate summary report
  report-default:
    needs: [build-default, test-default]
    if: always() && (github.event.inputs.base_image_tag == '' || github.event.inputs.base_image_tag == null)
    runs-on: ubuntu-latest
    steps:
      - name: Generate Report
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # ðŸ˜ Crunchy PostgreSQL Custom Image - Build Report

          ## ðŸ“¦ Published Images

          | PostgreSQL | Image | Tag |
          |------------|-------|-----|
          | PG 17 | `${{ env.DOCKERHUB_USERNAME }}/crunchy-postgres-custom` | `pg17-latest` |
          | PG 18 | `${{ env.DOCKERHUB_USERNAME }}/crunchy-postgres-custom` | `pg18-latest` |

          ## ðŸ§ª Validation Results

          | PostgreSQL | Status | Partitions | Records | Extensions |
          |------------|--------|------------|---------|------------|
          | PG 17 | ${{ needs.test-default.outputs.pg17_result == 'PASSED' && 'âœ… PASSED' || 'âŒ FAILED' }} | ${{ needs.test-default.outputs.pg17_partitions_before }} â†’ ${{ needs.test-default.outputs.pg17_partitions_after }} | ${{ needs.test-default.outputs.pg17_rows_before }} â†’ ${{ needs.test-default.outputs.pg17_rows_after }} | `${{ needs.test-default.outputs.pg17_shared_libs }}` |
          | PG 18 | ${{ needs.test-default.outputs.pg18_result == 'PASSED' && 'âœ… PASSED' || 'âŒ FAILED' }} | ${{ needs.test-default.outputs.pg18_partitions_before }} â†’ ${{ needs.test-default.outputs.pg18_partitions_after }} | ${{ needs.test-default.outputs.pg18_rows_before }} â†’ ${{ needs.test-default.outputs.pg18_rows_after }} | `${{ needs.test-default.outputs.pg18_shared_libs }}` |

          ## ðŸ“‹ Test Details

          - **Databases tested**: db1, db2
          - **Partition interval**: 1 minute
          - **Retention**: 5 minutes
          - **Test data**: 100 records (10 per minute, last 10 minutes)
          - **Expected**: Partitions reduced after maintenance, old data dropped
          EOF

  # Custom build: user-specified base image tag
  build-custom:
    if: github.event.inputs.base_image_tag != '' && github.event.inputs.base_image_tag != null
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ github.event.inputs.base_image_tag }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate timestamp
        id: timestamp
        run: echo "ts=$(date -u +%Y%m%dT%H%M%SZ)" >> $GITHUB_OUTPUT

      - name: Extract PG version from tag
        id: pg-version
        run: |
          PG_VERSION=$(echo "${{ github.event.inputs.base_image_tag }}" | sed -E 's/ubi[89]-([0-9]+)\..*/\1/')
          echo "version=$PG_VERSION" >> $GITHUB_OUTPUT

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            BASE_IMAGE_TAG=${{ github.event.inputs.base_image_tag }}
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/crunchy-postgres-custom:${{ github.event.inputs.base_image_tag }}-${{ steps.timestamp.outputs.ts }}
            ${{ secrets.DOCKERHUB_USERNAME }}/crunchy-postgres-custom:${{ github.event.inputs.base_image_tag }}
          cache-from: type=gha,scope=${{ github.event.inputs.base_image_tag }}
          cache-to: type=gha,mode=max,scope=${{ github.event.inputs.base_image_tag }}

  # Test custom build
  test-custom:
    needs: build-custom
    if: github.event.inputs.base_image_tag != '' && github.event.inputs.base_image_tag != null
    runs-on: ubuntu-latest
    outputs:
      result: ${{ steps.test-result.outputs.result }}
      partitions_before: ${{ steps.test-result.outputs.partitions_before }}
      partitions_after: ${{ steps.test-result.outputs.partitions_after }}
      rows_before: ${{ steps.test-result.outputs.rows_before }}
      rows_after: ${{ steps.test-result.outputs.rows_after }}
      shared_libs: ${{ steps.test-result.outputs.shared_libs }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract PG version from tag
        id: pg-version
        run: |
          PG_VERSION=$(echo "${{ github.event.inputs.base_image_tag }}" | sed -E 's/ubi[89]-([0-9]+)\..*/\1/')
          echo "version=$PG_VERSION" >> $GITHUB_OUTPUT

      - name: Create Kind cluster
        uses: helm/kind-action@v1
        with:
          cluster_name: pgo-test

      - name: Install PGO
        run: |
          git clone --depth 1 https://github.com/CrunchyData/postgres-operator.git /tmp/pgo
          kubectl apply -k /tmp/pgo/config/namespace
          kubectl apply --server-side -k /tmp/pgo/config/default
          kubectl wait --for=condition=Available deployment/pgo -n postgres-operator --timeout=180s

      - name: Pull and load image
        run: |
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/crunchy-postgres-custom:${{ github.event.inputs.base_image_tag }}
          kind load docker-image ${{ secrets.DOCKERHUB_USERNAME }}/crunchy-postgres-custom:${{ github.event.inputs.base_image_tag }} --name pgo-test

      - name: Deploy PostgresCluster
        env:
          IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/crunchy-postgres-custom
          IMAGE_TAG: ${{ github.event.inputs.base_image_tag }}
          POSTGRES_VERSION: ${{ steps.pg-version.outputs.version }}
        run: |
          envsubst < test/postgrescluster.yaml | kubectl apply -f -
          echo "Waiting for PostgresCluster to be ready..."
          for i in {1..60}; do
            READY=$(kubectl get postgrescluster partman-test -o jsonpath='{.status.instances[0].readyReplicas}' 2>/dev/null || echo "0")
            if [ "$READY" = "1" ]; then
              echo "PostgresCluster ready"
              break
            fi
            echo "Waiting... ($i/60)"
            sleep 5
          done

      - name: Setup pg_partman
        run: |
          POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')
          kubectl cp test/setup_partman.sql ${POD}:/tmp/setup_partman.sql -c database
          for db in db1 db2; do
            kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -f /tmp/setup_partman.sql -q
          done

      - name: Validate and capture results
        id: test-result
        run: |
          POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')

          SHARED_LIBS=$(kubectl exec ${POD} -c database -- psql -U postgres -t -c "SHOW shared_preload_libraries;" | tr -d ' ')
          echo "shared_preload_libraries: $SHARED_LIBS"

          RESULT="PASSED"

          for db in db1 db2; do
            echo "=== Testing ${db} ==="
            
            PARTITIONS_BEFORE=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM pg_tables WHERE tablename LIKE 'events_p%';" | tr -d ' ')
            ROWS_BEFORE=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM events;" | tr -d ' ')
            echo "Before: $PARTITIONS_BEFORE partitions, $ROWS_BEFORE rows"

            kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -c "CALL partman.run_maintenance_proc();" >/dev/null

            PARTITIONS_AFTER=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM pg_tables WHERE tablename LIKE 'events_p%';" | tr -d ' ')
            ROWS_AFTER=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM events;" | tr -d ' ')
            echo "After: $PARTITIONS_AFTER partitions, $ROWS_AFTER rows"

            if [ "$PARTITIONS_AFTER" -ge "$PARTITIONS_BEFORE" ]; then
              RESULT="FAILED"
            fi

            if [ "$db" = "db1" ]; then
              echo "partitions_before=$PARTITIONS_BEFORE" >> $GITHUB_OUTPUT
              echo "partitions_after=$PARTITIONS_AFTER" >> $GITHUB_OUTPUT
              echo "rows_before=$ROWS_BEFORE" >> $GITHUB_OUTPUT
              echo "rows_after=$ROWS_AFTER" >> $GITHUB_OUTPUT
            fi
          done

          if ! echo "$SHARED_LIBS" | grep -q "pg_partman_bgw"; then
            RESULT="FAILED"
          fi

          echo "result=$RESULT" >> $GITHUB_OUTPUT
          echo "shared_libs=$SHARED_LIBS" >> $GITHUB_OUTPUT

          if [ "$RESULT" = "FAILED" ]; then
            exit 1
          fi

  # Generate report for custom build
  report-custom:
    needs: [build-custom, test-custom]
    if: always() && github.event.inputs.base_image_tag != '' && github.event.inputs.base_image_tag != null
    runs-on: ubuntu-latest
    steps:
      - name: Extract PG version
        id: pg-version
        run: |
          PG_VERSION=$(echo "${{ github.event.inputs.base_image_tag }}" | sed -E 's/ubi[89]-([0-9]+)\..*/\1/')
          echo "version=$PG_VERSION" >> $GITHUB_OUTPUT

      - name: Generate Report
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          BASE_IMAGE_TAG: ${{ github.event.inputs.base_image_tag }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # ðŸ˜ Crunchy PostgreSQL Custom Image - Build Report

          ## ðŸ“¦ Published Image

          | PostgreSQL | Image | Tag |
          |------------|-------|-----|
          | PG ${{ steps.pg-version.outputs.version }} | `${{ env.DOCKERHUB_USERNAME }}/crunchy-postgres-custom` | `${{ env.BASE_IMAGE_TAG }}` |

          ## ðŸ§ª Validation Results

          | Status | Partitions | Records | Extensions |
          |--------|------------|---------|------------|
          | ${{ needs.test-custom.outputs.result == 'PASSED' && 'âœ… PASSED' || 'âŒ FAILED' }} | ${{ needs.test-custom.outputs.partitions_before }} â†’ ${{ needs.test-custom.outputs.partitions_after }} | ${{ needs.test-custom.outputs.rows_before }} â†’ ${{ needs.test-custom.outputs.rows_after }} | `${{ needs.test-custom.outputs.shared_libs }}` |

          ## ðŸ“‹ Test Details

          - **Databases tested**: db1, db2
          - **Partition interval**: 1 minute
          - **Retention**: 5 minutes
          EOF
