name: Build and Push Docker Image

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      base_image_tag:
        description: "Custom base image tag (leave empty for default PG 17 & 18 builds)"
        required: false
        default: ""

env:
  DOCKER_REPO: agdelen/crunchy-postgres-custom

jobs:
  # Default builds: PG 17 and PG 18 (runs on push or when no custom tag provided)
  build-default:
    if: github.event.inputs.base_image_tag == '' || github.event.inputs.base_image_tag == null
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - base_image_tag: ubi9-17.7-2550
            pg_version: "17"
          - base_image_tag: ubi9-18.1-2550
            pg_version: "18"
    outputs:
      pg17_tag_ts: ${{ steps.set-outputs.outputs.pg17_tag_ts }}
      pg17_tag_base: ${{ steps.set-outputs.outputs.pg17_tag_base }}
      pg17_tag_latest: ${{ steps.set-outputs.outputs.pg17_tag_latest }}
      pg18_tag_ts: ${{ steps.set-outputs.outputs.pg18_tag_ts }}
      pg18_tag_base: ${{ steps.set-outputs.outputs.pg18_tag_base }}
      pg18_tag_latest: ${{ steps.set-outputs.outputs.pg18_tag_latest }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate timestamp
        id: timestamp
        run: echo "ts=$(date -u +%Y%m%dT%H%M%SZ)" >> $GITHUB_OUTPUT

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            BASE_IMAGE_TAG=${{ matrix.base_image_tag }}
          tags: |
            ${{ env.DOCKER_REPO }}:${{ matrix.base_image_tag }}-${{ steps.timestamp.outputs.ts }}
            ${{ env.DOCKER_REPO }}:${{ matrix.base_image_tag }}
            ${{ env.DOCKER_REPO }}:pg${{ matrix.pg_version }}-latest
          cache-from: type=gha,scope=${{ matrix.base_image_tag }}
          cache-to: type=gha,mode=max,scope=${{ matrix.base_image_tag }}

      - name: Set outputs for test job
        id: set-outputs
        run: |
          TS="${{ steps.timestamp.outputs.ts }}"
          if [ "${{ matrix.pg_version }}" = "17" ]; then
            echo "pg17_tag_ts=${{ matrix.base_image_tag }}-${TS}" >> $GITHUB_OUTPUT
            echo "pg17_tag_base=${{ matrix.base_image_tag }}" >> $GITHUB_OUTPUT
            echo "pg17_tag_latest=pg17-latest" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.pg_version }}" = "18" ]; then
            echo "pg18_tag_ts=${{ matrix.base_image_tag }}-${TS}" >> $GITHUB_OUTPUT
            echo "pg18_tag_base=${{ matrix.base_image_tag }}" >> $GITHUB_OUTPUT
            echo "pg18_tag_latest=pg18-latest" >> $GITHUB_OUTPUT
          fi

  # Test both PG 17 and PG 18 images
  test-default:
    needs: build-default
    if: github.event.inputs.base_image_tag == '' || github.event.inputs.base_image_tag == null
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - pg_version: "17"
            image_tag: "pg17-latest"
          - pg_version: "18"
            image_tag: "pg18-latest"
    outputs:
      pg17_result: ${{ steps.test-result.outputs.pg17_result }}
      pg18_result: ${{ steps.test-result.outputs.pg18_result }}
      pg17_partitions_before: ${{ steps.test-result.outputs.pg17_partitions_before }}
      pg17_partitions_after: ${{ steps.test-result.outputs.pg17_partitions_after }}
      pg18_partitions_before: ${{ steps.test-result.outputs.pg18_partitions_before }}
      pg18_partitions_after: ${{ steps.test-result.outputs.pg18_partitions_after }}
      pg17_rows_before: ${{ steps.test-result.outputs.pg17_rows_before }}
      pg17_rows_after: ${{ steps.test-result.outputs.pg17_rows_after }}
      pg18_rows_before: ${{ steps.test-result.outputs.pg18_rows_before }}
      pg18_rows_after: ${{ steps.test-result.outputs.pg18_rows_after }}
      pg17_shared_libs: ${{ steps.test-result.outputs.pg17_shared_libs }}
      pg18_shared_libs: ${{ steps.test-result.outputs.pg18_shared_libs }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create Kind cluster
        uses: helm/kind-action@v1
        with:
          cluster_name: pgo-test

      - name: Install PGO
        run: |
          git clone --depth 1 https://github.com/CrunchyData/postgres-operator.git /tmp/pgo
          kubectl apply -k /tmp/pgo/config/namespace
          kubectl apply --server-side -k /tmp/pgo/config/default
          kubectl wait --for=condition=Available deployment/pgo -n postgres-operator --timeout=180s

      - name: Pull and load image
        run: |
          docker pull ${{ env.DOCKER_REPO }}:${{ matrix.image_tag }}
          kind load docker-image ${{ env.DOCKER_REPO }}:${{ matrix.image_tag }} --name pgo-test

      - name: Deploy PostgresCluster
        env:
          IMAGE_NAME: ${{ env.DOCKER_REPO }}
          IMAGE_TAG: ${{ matrix.image_tag }}
          POSTGRES_VERSION: ${{ matrix.pg_version }}
        run: |
          envsubst < test/postgrescluster.yaml | kubectl apply -f -
          echo "Waiting for PostgresCluster to be ready..."
          for i in {1..60}; do
            READY=$(kubectl get postgrescluster partman-test -o jsonpath='{.status.instances[0].readyReplicas}' 2>/dev/null || echo "0")
            if [ "$READY" = "1" ]; then
              echo "PostgresCluster ready"
              break
            fi
            echo "Waiting... ($i/60)"
            sleep 5
          done

      - name: Setup pg_partman
        run: |
          POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')
          kubectl cp test/setup_partman.sql ${POD}:/tmp/setup_partman.sql -c database
          for db in db1 db2; do
            kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -f /tmp/setup_partman.sql -q
          done

      - name: Validate and capture results
        id: test-result
        run: |
          POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')

          SHARED_LIBS=$(kubectl exec ${POD} -c database -- psql -U postgres -t -c "SHOW shared_preload_libraries;" | tr -d ' ')
          echo "shared_preload_libraries: $SHARED_LIBS"

          RESULT="PASSED"
          PARTITIONS_BEFORE=""
          PARTITIONS_AFTER=""
          ROWS_BEFORE=""
          ROWS_AFTER=""

          # Test both databases
          for db in db1 db2; do
            echo "=== Testing ${db} ==="
            
            P_BEFORE=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM pg_tables WHERE tablename LIKE 'events_p%';" | tr -d ' ')
            R_BEFORE=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM events;" | tr -d ' ')
            echo "Before: $P_BEFORE partitions, $R_BEFORE rows"

            kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -c "CALL partman.run_maintenance_proc();" >/dev/null

            P_AFTER=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM pg_tables WHERE tablename LIKE 'events_p%';" | tr -d ' ')
            R_AFTER=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM events;" | tr -d ' ')
            echo "After: $P_AFTER partitions, $R_AFTER rows"

            DROPPED=$((P_BEFORE - P_AFTER))
            echo "Result: ${DROPPED} partitions dropped"

            if [ "$P_AFTER" -ge "$P_BEFORE" ]; then
              echo "FAILED: Retention not working in ${db}"
              RESULT="FAILED"
            fi

            # Save results for first db (db1) for summary
            if [ "$db" = "db1" ]; then
              PARTITIONS_BEFORE="$P_BEFORE"
              PARTITIONS_AFTER="$P_AFTER"
              ROWS_BEFORE="$R_BEFORE"
              ROWS_AFTER="$R_AFTER"
            fi
          done

          if ! echo "$SHARED_LIBS" | grep -q "pg_partman_bgw"; then
            echo "FAILED: pg_partman_bgw not in shared_preload_libraries"
            RESULT="FAILED"
          fi

          echo "Test result: $RESULT"

          # Set outputs based on PG version
          if [ "${{ matrix.pg_version }}" = "17" ]; then
            echo "pg17_result=$RESULT" >> $GITHUB_OUTPUT
            echo "pg17_partitions_before=$PARTITIONS_BEFORE" >> $GITHUB_OUTPUT
            echo "pg17_partitions_after=$PARTITIONS_AFTER" >> $GITHUB_OUTPUT
            echo "pg17_rows_before=$ROWS_BEFORE" >> $GITHUB_OUTPUT
            echo "pg17_rows_after=$ROWS_AFTER" >> $GITHUB_OUTPUT
            echo "pg17_shared_libs=$SHARED_LIBS" >> $GITHUB_OUTPUT
          else
            echo "pg18_result=$RESULT" >> $GITHUB_OUTPUT
            echo "pg18_partitions_before=$PARTITIONS_BEFORE" >> $GITHUB_OUTPUT
            echo "pg18_partitions_after=$PARTITIONS_AFTER" >> $GITHUB_OUTPUT
            echo "pg18_rows_before=$ROWS_BEFORE" >> $GITHUB_OUTPUT
            echo "pg18_rows_after=$ROWS_AFTER" >> $GITHUB_OUTPUT
            echo "pg18_shared_libs=$SHARED_LIBS" >> $GITHUB_OUTPUT
          fi

          if [ "$RESULT" = "FAILED" ]; then
            exit 1
          fi

  # Generate summary report
  report-default:
    needs: [build-default, test-default]
    if: always() && (github.event.inputs.base_image_tag == '' || github.event.inputs.base_image_tag == null)
    runs-on: ubuntu-latest
    steps:
      - name: Generate Report
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ðŸ˜ Crunchy PostgreSQL Custom Image - Build Report

          ## ðŸ“¦ Published Images

          | PostgreSQL | Image | Tags |
          |------------|-------|------|
          | PG 17 | [\`${{ env.DOCKER_REPO }}\`](https://hub.docker.com/r/${{ env.DOCKER_REPO }}) | \`${{ needs.build-default.outputs.pg17_tag_latest }}\`, \`${{ needs.build-default.outputs.pg17_tag_base }}\`, \`${{ needs.build-default.outputs.pg17_tag_ts }}\` |
          | PG 18 | [\`${{ env.DOCKER_REPO }}\`](https://hub.docker.com/r/${{ env.DOCKER_REPO }}) | \`${{ needs.build-default.outputs.pg18_tag_latest }}\`, \`${{ needs.build-default.outputs.pg18_tag_base }}\`, \`${{ needs.build-default.outputs.pg18_tag_ts }}\` |

          ## ðŸ§ª pg_partman_bgw Retention Test

          | PostgreSQL | Status | Partitions | Records | Extensions |
          |------------|--------|------------|---------|------------|
          | PG 17 | ${{ needs.test-default.outputs.pg17_result == 'PASSED' && 'âœ… PASSED' || 'âŒ FAILED' }} | ${{ needs.test-default.outputs.pg17_partitions_before }} â†’ ${{ needs.test-default.outputs.pg17_partitions_after }} | ${{ needs.test-default.outputs.pg17_rows_before }} â†’ ${{ needs.test-default.outputs.pg17_rows_after }} | \`${{ needs.test-default.outputs.pg17_shared_libs }}\` |
          | PG 18 | ${{ needs.test-default.outputs.pg18_result == 'PASSED' && 'âœ… PASSED' || 'âŒ FAILED' }} | ${{ needs.test-default.outputs.pg18_partitions_before }} â†’ ${{ needs.test-default.outputs.pg18_partitions_after }} | ${{ needs.test-default.outputs.pg18_rows_before }} â†’ ${{ needs.test-default.outputs.pg18_rows_after }} | \`${{ needs.test-default.outputs.pg18_shared_libs }}\` |

          **Test Config**: 1-minute partitions, 5-minute retention, 100 records across 10 minutes, tested on db1 & db2
          EOF

  # Custom build: user-specified base image tag
  build-custom:
    if: github.event.inputs.base_image_tag != '' && github.event.inputs.base_image_tag != null
    runs-on: ubuntu-latest
    outputs:
      tag_ts: ${{ steps.set-outputs.outputs.tag_ts }}
      tag_base: ${{ steps.set-outputs.outputs.tag_base }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate timestamp
        id: timestamp
        run: echo "ts=$(date -u +%Y%m%dT%H%M%SZ)" >> $GITHUB_OUTPUT

      - name: Extract PG version from tag
        id: pg-version
        run: |
          PG_VERSION=$(echo "${{ github.event.inputs.base_image_tag }}" | sed -E 's/ubi[89]-([0-9]+)\..*/\1/')
          echo "version=$PG_VERSION" >> $GITHUB_OUTPUT

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            BASE_IMAGE_TAG=${{ github.event.inputs.base_image_tag }}
          tags: |
            ${{ env.DOCKER_REPO }}:${{ github.event.inputs.base_image_tag }}-${{ steps.timestamp.outputs.ts }}
            ${{ env.DOCKER_REPO }}:${{ github.event.inputs.base_image_tag }}
          cache-from: type=gha,scope=${{ github.event.inputs.base_image_tag }}
          cache-to: type=gha,mode=max,scope=${{ github.event.inputs.base_image_tag }}

      - name: Set outputs
        id: set-outputs
        run: |
          echo "tag_ts=${{ github.event.inputs.base_image_tag }}-${{ steps.timestamp.outputs.ts }}" >> $GITHUB_OUTPUT
          echo "tag_base=${{ github.event.inputs.base_image_tag }}" >> $GITHUB_OUTPUT

  # Test custom build
  test-custom:
    needs: build-custom
    if: github.event.inputs.base_image_tag != '' && github.event.inputs.base_image_tag != null
    runs-on: ubuntu-latest
    outputs:
      result: ${{ steps.test-result.outputs.result }}
      partitions_before: ${{ steps.test-result.outputs.partitions_before }}
      partitions_after: ${{ steps.test-result.outputs.partitions_after }}
      rows_before: ${{ steps.test-result.outputs.rows_before }}
      rows_after: ${{ steps.test-result.outputs.rows_after }}
      shared_libs: ${{ steps.test-result.outputs.shared_libs }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract PG version from tag
        id: pg-version
        run: |
          PG_VERSION=$(echo "${{ github.event.inputs.base_image_tag }}" | sed -E 's/ubi[89]-([0-9]+)\..*/\1/')
          echo "version=$PG_VERSION" >> $GITHUB_OUTPUT

      - name: Create Kind cluster
        uses: helm/kind-action@v1
        with:
          cluster_name: pgo-test

      - name: Install PGO
        run: |
          git clone --depth 1 https://github.com/CrunchyData/postgres-operator.git /tmp/pgo
          kubectl apply -k /tmp/pgo/config/namespace
          kubectl apply --server-side -k /tmp/pgo/config/default
          kubectl wait --for=condition=Available deployment/pgo -n postgres-operator --timeout=180s

      - name: Pull and load image
        run: |
          docker pull ${{ env.DOCKER_REPO }}:${{ github.event.inputs.base_image_tag }}
          kind load docker-image ${{ env.DOCKER_REPO }}:${{ github.event.inputs.base_image_tag }} --name pgo-test

      - name: Deploy PostgresCluster
        env:
          IMAGE_NAME: ${{ env.DOCKER_REPO }}
          IMAGE_TAG: ${{ github.event.inputs.base_image_tag }}
          POSTGRES_VERSION: ${{ steps.pg-version.outputs.version }}
        run: |
          envsubst < test/postgrescluster.yaml | kubectl apply -f -
          echo "Waiting for PostgresCluster to be ready..."
          for i in {1..60}; do
            READY=$(kubectl get postgrescluster partman-test -o jsonpath='{.status.instances[0].readyReplicas}' 2>/dev/null || echo "0")
            if [ "$READY" = "1" ]; then
              echo "PostgresCluster ready"
              break
            fi
            echo "Waiting... ($i/60)"
            sleep 5
          done

      - name: Setup pg_partman
        run: |
          POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')
          kubectl cp test/setup_partman.sql ${POD}:/tmp/setup_partman.sql -c database
          for db in db1 db2; do
            kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -f /tmp/setup_partman.sql -q
          done

      - name: Validate and capture results
        id: test-result
        run: |
          POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')

          SHARED_LIBS=$(kubectl exec ${POD} -c database -- psql -U postgres -t -c "SHOW shared_preload_libraries;" | tr -d ' ')
          echo "shared_preload_libraries: $SHARED_LIBS"

          RESULT="PASSED"
          PARTITIONS_BEFORE=""
          PARTITIONS_AFTER=""
          ROWS_BEFORE=""
          ROWS_AFTER=""

          for db in db1 db2; do
            echo "=== Testing ${db} ==="
            
            P_BEFORE=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM pg_tables WHERE tablename LIKE 'events_p%';" | tr -d ' ')
            R_BEFORE=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM events;" | tr -d ' ')
            echo "Before: $P_BEFORE partitions, $R_BEFORE rows"

            kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -c "CALL partman.run_maintenance_proc();" >/dev/null

            P_AFTER=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM pg_tables WHERE tablename LIKE 'events_p%';" | tr -d ' ')
            R_AFTER=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM events;" | tr -d ' ')
            echo "After: $P_AFTER partitions, $R_AFTER rows"

            if [ "$P_AFTER" -ge "$P_BEFORE" ]; then
              RESULT="FAILED"
            fi

            if [ "$db" = "db1" ]; then
              PARTITIONS_BEFORE="$P_BEFORE"
              PARTITIONS_AFTER="$P_AFTER"
              ROWS_BEFORE="$R_BEFORE"
              ROWS_AFTER="$R_AFTER"
            fi
          done

          if ! echo "$SHARED_LIBS" | grep -q "pg_partman_bgw"; then
            RESULT="FAILED"
          fi

          echo "result=$RESULT" >> $GITHUB_OUTPUT
          echo "partitions_before=$PARTITIONS_BEFORE" >> $GITHUB_OUTPUT
          echo "partitions_after=$PARTITIONS_AFTER" >> $GITHUB_OUTPUT
          echo "rows_before=$ROWS_BEFORE" >> $GITHUB_OUTPUT
          echo "rows_after=$ROWS_AFTER" >> $GITHUB_OUTPUT
          echo "shared_libs=$SHARED_LIBS" >> $GITHUB_OUTPUT

          if [ "$RESULT" = "FAILED" ]; then
            exit 1
          fi

  # Generate report for custom build
  report-custom:
    needs: [build-custom, test-custom]
    if: always() && github.event.inputs.base_image_tag != '' && github.event.inputs.base_image_tag != null
    runs-on: ubuntu-latest
    steps:
      - name: Extract PG version
        id: pg-version
        run: |
          PG_VERSION=$(echo "${{ github.event.inputs.base_image_tag }}" | sed -E 's/ubi[89]-([0-9]+)\..*/\1/')
          echo "version=$PG_VERSION" >> $GITHUB_OUTPUT

      - name: Generate Report
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ðŸ˜ Crunchy PostgreSQL Custom Image - Build Report

          ## ðŸ“¦ Published Image

          | PostgreSQL | Image | Tags |
          |------------|-------|------|
          | PG ${{ steps.pg-version.outputs.version }} | [\`${{ env.DOCKER_REPO }}\`](https://hub.docker.com/r/${{ env.DOCKER_REPO }}) | \`${{ needs.build-custom.outputs.tag_base }}\`, \`${{ needs.build-custom.outputs.tag_ts }}\` |

          ## ðŸ§ª pg_partman_bgw Retention Test

          | Status | Partitions | Records | Extensions |
          |--------|------------|---------|------------|
          | ${{ needs.test-custom.outputs.result == 'PASSED' && 'âœ… PASSED' || 'âŒ FAILED' }} | ${{ needs.test-custom.outputs.partitions_before }} â†’ ${{ needs.test-custom.outputs.partitions_after }} | ${{ needs.test-custom.outputs.rows_before }} â†’ ${{ needs.test-custom.outputs.rows_after }} | \`${{ needs.test-custom.outputs.shared_libs }}\` |

          **Test Config**: 1-minute partitions, 5-minute retention, 100 records across 10 minutes, tested on db1 & db2
          EOF
