[env]
CLUSTER_NAME = "pgo-test"
IMAGE_NAME = "agdelen/crunchy-postgres-custom"
IMAGE_TAG = "ubi8-17.2-2"
POSTGRES_VERSION = "17"
DATABASES = "db1 db2 db3 db4 db5"
WAIT_TIMEOUT = "180s"

[tasks.test]
description = "Run full e2e test (cluster setup + validation)"
depends = ["cluster-up", "pgo-install", "deploy", "setup-partman", "validate"]

[tasks.test-quick]
description = "Run validation only (assumes cluster exists)"
depends = ["validate"]

[tasks.cluster-up]
description = "Create Kind cluster"
run = """
#!/usr/bin/env bash
set -e
if kind get clusters 2>/dev/null | grep -q "^${CLUSTER_NAME}$"; then
  echo "✓ Cluster ${CLUSTER_NAME} already exists"
else
  echo "→ Creating Kind cluster: ${CLUSTER_NAME}"
  kind create cluster --name ${CLUSTER_NAME}
fi
"""

[tasks.cluster-down]
description = "Delete Kind cluster"
run = """
#!/usr/bin/env bash
kind delete cluster --name ${CLUSTER_NAME} 2>/dev/null || true
echo "✓ Cluster ${CLUSTER_NAME} deleted"
"""

[tasks.pgo-install]
description = "Install Crunchy PostgreSQL Operator"
run = """
#!/usr/bin/env bash
set -e

# Check if PGO is already installed
if kubectl get deployment pgo -n postgres-operator &>/dev/null; then
  echo "✓ PGO already installed"
  exit 0
fi

echo "→ Cloning postgres-operator repo..."
TEMP_DIR=$(mktemp -d)
git clone --depth 1 https://github.com/CrunchyData/postgres-operator.git "$TEMP_DIR/pgo"

echo "→ Installing PGO..."
kubectl apply -k "$TEMP_DIR/pgo/config/namespace"
kubectl apply --server-side -k "$TEMP_DIR/pgo/config/default"

echo "→ Waiting for PGO to be ready..."
kubectl wait --for=condition=Available deployment/pgo -n postgres-operator --timeout=${WAIT_TIMEOUT}

rm -rf "$TEMP_DIR"
echo "✓ PGO installed"
"""

[tasks.load-image]
description = "Pull and load image into Kind"
run = """
#!/usr/bin/env bash
set -e
FULL_IMAGE="${IMAGE_NAME}:${IMAGE_TAG}"

echo "→ Pulling image: ${FULL_IMAGE}"
docker pull ${FULL_IMAGE}

echo "→ Loading image into Kind cluster..."
kind load docker-image ${FULL_IMAGE} --name ${CLUSTER_NAME}

echo "✓ Image loaded"
"""

[tasks.deploy]
description = "Deploy PostgresCluster with 5 databases"
depends = ["load-image"]
run = """
#!/usr/bin/env bash
set -e

# Delete existing cluster if any
kubectl delete postgrescluster partman-test --ignore-not-found=true

echo "→ Deploying PostgresCluster with image: ${IMAGE_NAME}:${IMAGE_TAG} (PG ${POSTGRES_VERSION})"
envsubst < test/postgrescluster.yaml | kubectl apply -f -

echo "→ Waiting for PostgresCluster to be ready..."
for i in {1..60}; do
  READY=$(kubectl get postgrescluster partman-test -o jsonpath='{.status.instances[0].readyReplicas}' 2>/dev/null || echo "0")
  if [ "$READY" = "1" ]; then
    echo "✓ PostgresCluster ready"
    break
  fi
  echo "  Waiting... ($i/60)"
  sleep 5
done

# Get pod name
POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')
echo "✓ Master pod: ${POD}"
"""

[tasks.setup-partman]
description = "Setup pg_partman tables in all databases"
run = """
#!/usr/bin/env bash
set -e

POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')

echo "→ Copying setup script to pod..."
kubectl cp test/setup_partman.sql ${POD}:/tmp/setup_partman.sql -c database

for db in ${DATABASES}; do
  echo "→ Setting up pg_partman in ${db}..."
  kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -f /tmp/setup_partman.sql -q
done

echo "✓ pg_partman setup complete"
"""

[tasks.validate]
description = "Validate pg_partman_bgw is working"
run = """
#!/usr/bin/env bash
set -e

POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')

echo ""
echo "=== Validation Results ==="
echo ""

# Check shared_preload_libraries
echo "1. shared_preload_libraries:"
kubectl exec ${POD} -c database -- psql -U postgres -t -c "SHOW shared_preload_libraries;" | tr -d ' '

# Check pg_partman_bgw logs
echo ""
echo "2. pg_partman_bgw log entries:"
kubectl exec ${POD} -c database -- cat /pgdata/logs/postgres/*.log 2>/dev/null | grep -i "pg_partman" | tail -5 || echo "   (no log entries yet)"

# Check partition counts
echo ""
echo "3. Partition counts per database:"
for db in ${DATABASES}; do
  COUNT=$(kubectl exec ${POD} -c database -- psql -U postgres -d ${db} -t -c "SELECT COUNT(*) FROM pg_tables WHERE tablename LIKE 'events_p%';" 2>/dev/null | tr -d ' ')
  echo "   ${db}: ${COUNT} partitions"
done

# Check part_config
echo ""
echo "4. pg_partman config (db1):"
kubectl exec ${POD} -c database -- psql -U postgres -d db1 -c "SELECT parent_table, partition_interval, retention, automatic_maintenance FROM partman.part_config;" 2>/dev/null || echo "   (not configured yet)"

echo ""
echo "=== Validation Complete ==="
"""

[tasks.validate-retention]
description = "Wait and validate retention is working (takes ~3 minutes)"
run = """
#!/usr/bin/env bash
set -e

POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')

echo "→ Getting initial partition count..."
INITIAL=$(kubectl exec ${POD} -c database -- psql -U postgres -d db1 -t -c "SELECT COUNT(*) FROM pg_tables WHERE tablename LIKE 'events_p%';" | tr -d ' ')
echo "  Initial: ${INITIAL} partitions"

echo "→ Waiting 3 minutes for retention to kick in..."
for i in {1..18}; do
  sleep 10
  COUNT=$(kubectl exec ${POD} -c database -- psql -U postgres -d db1 -t -c "SELECT COUNT(*) FROM pg_tables WHERE tablename LIKE 'events_p%';" | tr -d ' ')
  echo "  [$(($i * 10))s] ${COUNT} partitions"
done

FINAL=$(kubectl exec ${POD} -c database -- psql -U postgres -d db1 -t -c "SELECT COUNT(*) FROM pg_tables WHERE tablename LIKE 'events_p%';" | tr -d ' ')

echo ""
if [ "$FINAL" -lt "$INITIAL" ]; then
  echo "✓ Retention is working! Partitions reduced from ${INITIAL} to ${FINAL}"
else
  echo "⚠ Retention may not be working. Partitions: ${INITIAL} → ${FINAL}"
fi
"""

[tasks.logs]
description = "Show pg_partman_bgw logs"
run = """
#!/usr/bin/env bash
POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')
kubectl exec ${POD} -c database -- cat /pgdata/logs/postgres/*.log 2>/dev/null | grep -i "pg_partman" || echo "No partman logs found"
"""

[tasks.psql]
description = "Connect to db1 via psql"
run = """
#!/usr/bin/env bash
POD=$(kubectl get pods -l postgres-operator.crunchydata.com/cluster=partman-test,postgres-operator.crunchydata.com/role=master -o jsonpath='{.items[0].metadata.name}')
kubectl exec -it ${POD} -c database -- psql -U postgres -d db1
"""

[tasks.clean]
description = "Full cleanup (delete cluster and images)"
depends = ["cluster-down"]
run = """
#!/usr/bin/env bash
docker rmi ${IMAGE_NAME}:${IMAGE_TAG} 2>/dev/null || true
echo "✓ Cleanup complete"
"""

[tasks.build-local]
description = "Build image locally"
run = """
#!/usr/bin/env bash
set -e
echo "→ Building image locally..."
docker build -t ${IMAGE_NAME}:local .
echo "✓ Built: ${IMAGE_NAME}:local"
"""
